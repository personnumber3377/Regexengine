# Generated from regex.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\26")
        buf.write("s\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\3\2\3\2\3\2\3\3")
        buf.write("\7\3\35\n\3\f\3\16\3 \13\3\3\3\7\3#\n\3\f\3\16\3&\13\3")
        buf.write("\3\4\3\4\7\4*\n\4\f\4\16\4-\13\4\3\5\3\5\5\5\61\n\5\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6<\n\6\3\7\3\7\3")
        buf.write("\7\3\7\6\7B\n\7\r\7\16\7C\3\7\3\7\3\7\5\7I\n\7\5\7K\n")
        buf.write("\7\3\7\3\7\3\7\3\b\3\b\5\bR\n\b\3\b\7\bU\n\b\f\b\16\b")
        buf.write("X\13\b\3\b\3\b\3\t\3\t\3\t\5\t_\n\t\3\t\5\tb\n\t\3\n\3")
        buf.write("\n\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\5\fq")
        buf.write("\n\f\3\f\2\2\r\2\4\6\b\n\f\16\20\22\24\26\2\4\5\2\5\5")
        buf.write("\b\16\20\26\4\2\17\23\26\26\2\u0080\2\30\3\2\2\2\4\36")
        buf.write("\3\2\2\2\6\'\3\2\2\2\b.\3\2\2\2\n;\3\2\2\2\f=\3\2\2\2")
        buf.write("\16O\3\2\2\2\20a\3\2\2\2\22c\3\2\2\2\24e\3\2\2\2\26p\3")
        buf.write("\2\2\2\30\31\5\4\3\2\31\32\7\2\2\3\32\3\3\2\2\2\33\35")
        buf.write("\5\b\5\2\34\33\3\2\2\2\35 \3\2\2\2\36\34\3\2\2\2\36\37")
        buf.write("\3\2\2\2\37$\3\2\2\2 \36\3\2\2\2!#\5\6\4\2\"!\3\2\2\2")
        buf.write("#&\3\2\2\2$\"\3\2\2\2$%\3\2\2\2%\5\3\2\2\2&$\3\2\2\2\'")
        buf.write("+\7\3\2\2(*\5\b\5\2)(\3\2\2\2*-\3\2\2\2+)\3\2\2\2+,\3")
        buf.write("\2\2\2,\7\3\2\2\2-+\3\2\2\2.\60\5\n\6\2/\61\5\26\f\2\60")
        buf.write("/\3\2\2\2\60\61\3\2\2\2\61\t\3\2\2\2\62<\5\f\7\2\63<\5")
        buf.write("\24\13\2\64<\7\5\2\2\65<\7\7\2\2\66<\5\16\b\2\67<\7\6")
        buf.write("\2\28<\7\25\2\29<\7\24\2\2:<\7\f\2\2;\62\3\2\2\2;\63\3")
        buf.write("\2\2\2;\64\3\2\2\2;\65\3\2\2\2;\66\3\2\2\2;\67\3\2\2\2")
        buf.write(";8\3\2\2\2;9\3\2\2\2;:\3\2\2\2<\13\3\2\2\2=J\7\b\2\2>")
        buf.write("H\7\r\2\2?A\7\22\2\2@B\7\26\2\2A@\3\2\2\2BC\3\2\2\2CA")
        buf.write("\3\2\2\2CD\3\2\2\2DE\3\2\2\2EI\7\21\2\2FI\7\23\2\2GI\7")
        buf.write("\21\2\2H?\3\2\2\2HF\3\2\2\2HG\3\2\2\2IK\3\2\2\2J>\3\2")
        buf.write("\2\2JK\3\2\2\2KL\3\2\2\2LM\5\4\3\2MN\7\t\2\2N\r\3\2\2")
        buf.write("\2OQ\7\16\2\2PR\7\24\2\2QP\3\2\2\2QR\3\2\2\2RV\3\2\2\2")
        buf.write("SU\5\20\t\2TS\3\2\2\2UX\3\2\2\2VT\3\2\2\2VW\3\2\2\2WY")
        buf.write("\3\2\2\2XV\3\2\2\2YZ\7\17\2\2Z\17\3\2\2\2[^\5\22\n\2\\")
        buf.write("]\7\20\2\2]_\5\22\n\2^\\\3\2\2\2^_\3\2\2\2_b\3\2\2\2`")
        buf.write("b\7\7\2\2a[\3\2\2\2a`\3\2\2\2b\21\3\2\2\2cd\t\2\2\2d\23")
        buf.write("\3\2\2\2ef\t\3\2\2f\25\3\2\2\2gq\7\n\2\2hq\7\13\2\2iq")
        buf.write("\7\r\2\2jk\7\n\2\2kq\7\r\2\2lm\7\13\2\2mq\7\r\2\2no\7")
        buf.write("\r\2\2oq\7\r\2\2pg\3\2\2\2ph\3\2\2\2pi\3\2\2\2pj\3\2\2")
        buf.write("\2pl\3\2\2\2pn\3\2\2\2q\27\3\2\2\2\17\36$+\60;CHJQV^a")
        buf.write("p")
        return buf.getvalue()


class regexParser ( Parser ):

    grammarFileName = "regex.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'|'", "'\\'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'*'", "'+'", "'.'", "'?'", 
                     "'['", "']'", "'-'", "'>'", "'<'", "':'", "'^'", "'$'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "BACKSLASH", "ESCAPED_RESERVED_CHAR", 
                      "BACKREFERENCE", "CHARACTER_CLASS", "OPEN_PAR", "CLOSE_PAR", 
                      "ASTERISK", "PLUS", "DOT", "QUESTION_MARK", "OPEN_BRACKET", 
                      "CLOSE_BRACKET", "DASH", "GREATER_THAN", "LOWER_THAN", 
                      "COLON", "CARET", "DOLLAR", "CHAR" ]

    RULE_main = 0
    RULE_regex = 1
    RULE_alternative = 2
    RULE_expr = 3
    RULE_subexpr = 4
    RULE_regexGroup = 5
    RULE_complexCharacterClass = 6
    RULE_complexCCPiece = 7
    RULE_allowedCharInCharacterClass = 8
    RULE_atomicChar = 9
    RULE_quantifier = 10

    ruleNames =  [ "main", "regex", "alternative", "expr", "subexpr", "regexGroup", 
                   "complexCharacterClass", "complexCCPiece", "allowedCharInCharacterClass", 
                   "atomicChar", "quantifier" ]

    EOF = Token.EOF
    T__0=1
    BACKSLASH=2
    ESCAPED_RESERVED_CHAR=3
    BACKREFERENCE=4
    CHARACTER_CLASS=5
    OPEN_PAR=6
    CLOSE_PAR=7
    ASTERISK=8
    PLUS=9
    DOT=10
    QUESTION_MARK=11
    OPEN_BRACKET=12
    CLOSE_BRACKET=13
    DASH=14
    GREATER_THAN=15
    LOWER_THAN=16
    COLON=17
    CARET=18
    DOLLAR=19
    CHAR=20

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class MainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def regex(self):
            return self.getTypedRuleContext(regexParser.RegexContext,0)


        def EOF(self):
            return self.getToken(regexParser.EOF, 0)

        def getRuleIndex(self):
            return regexParser.RULE_main

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMain" ):
                listener.enterMain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMain" ):
                listener.exitMain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMain" ):
                return visitor.visitMain(self)
            else:
                return visitor.visitChildren(self)




    def main(self):

        localctx = regexParser.MainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_main)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 22
            self.regex()
            self.state = 23
            self.match(regexParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(regexParser.ExprContext)
            else:
                return self.getTypedRuleContext(regexParser.ExprContext,i)


        def alternative(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(regexParser.AlternativeContext)
            else:
                return self.getTypedRuleContext(regexParser.AlternativeContext,i)


        def getRuleIndex(self):
            return regexParser.RULE_regex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegex" ):
                listener.enterRegex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegex" ):
                listener.exitRegex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegex" ):
                return visitor.visitRegex(self)
            else:
                return visitor.visitChildren(self)




    def regex(self):

        localctx = regexParser.RegexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_regex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 28
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << regexParser.ESCAPED_RESERVED_CHAR) | (1 << regexParser.BACKREFERENCE) | (1 << regexParser.CHARACTER_CLASS) | (1 << regexParser.OPEN_PAR) | (1 << regexParser.DOT) | (1 << regexParser.OPEN_BRACKET) | (1 << regexParser.CLOSE_BRACKET) | (1 << regexParser.DASH) | (1 << regexParser.GREATER_THAN) | (1 << regexParser.LOWER_THAN) | (1 << regexParser.COLON) | (1 << regexParser.CARET) | (1 << regexParser.DOLLAR) | (1 << regexParser.CHAR))) != 0):
                self.state = 25
                self.expr()
                self.state = 30
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 34
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==regexParser.T__0:
                self.state = 31
                self.alternative()
                self.state = 36
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AlternativeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(regexParser.ExprContext)
            else:
                return self.getTypedRuleContext(regexParser.ExprContext,i)


        def getRuleIndex(self):
            return regexParser.RULE_alternative

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlternative" ):
                listener.enterAlternative(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlternative" ):
                listener.exitAlternative(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlternative" ):
                return visitor.visitAlternative(self)
            else:
                return visitor.visitChildren(self)




    def alternative(self):

        localctx = regexParser.AlternativeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_alternative)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self.match(regexParser.T__0)
            self.state = 41
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << regexParser.ESCAPED_RESERVED_CHAR) | (1 << regexParser.BACKREFERENCE) | (1 << regexParser.CHARACTER_CLASS) | (1 << regexParser.OPEN_PAR) | (1 << regexParser.DOT) | (1 << regexParser.OPEN_BRACKET) | (1 << regexParser.CLOSE_BRACKET) | (1 << regexParser.DASH) | (1 << regexParser.GREATER_THAN) | (1 << regexParser.LOWER_THAN) | (1 << regexParser.COLON) | (1 << regexParser.CARET) | (1 << regexParser.DOLLAR) | (1 << regexParser.CHAR))) != 0):
                self.state = 38
                self.expr()
                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subexpr(self):
            return self.getTypedRuleContext(regexParser.SubexprContext,0)


        def quantifier(self):
            return self.getTypedRuleContext(regexParser.QuantifierContext,0)


        def getRuleIndex(self):
            return regexParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = regexParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.subexpr()
            self.state = 46
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << regexParser.ASTERISK) | (1 << regexParser.PLUS) | (1 << regexParser.QUESTION_MARK))) != 0):
                self.state = 45
                self.quantifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubexprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return regexParser.RULE_subexpr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DotPatternContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOT(self):
            return self.getToken(regexParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDotPattern" ):
                listener.enterDotPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDotPattern" ):
                listener.exitDotPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDotPattern" ):
                return visitor.visitDotPattern(self)
            else:
                return visitor.visitChildren(self)


    class ComplexClassContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def complexCharacterClass(self):
            return self.getTypedRuleContext(regexParser.ComplexCharacterClassContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexClass" ):
                listener.enterComplexClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexClass" ):
                listener.exitComplexClass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexClass" ):
                return visitor.visitComplexClass(self)
            else:
                return visitor.visitChildren(self)


    class BackreferenceContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BACKREFERENCE(self):
            return self.getToken(regexParser.BACKREFERENCE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBackreference" ):
                listener.enterBackreference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBackreference" ):
                listener.exitBackreference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBackreference" ):
                return visitor.visitBackreference(self)
            else:
                return visitor.visitChildren(self)


    class GroupPatternContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regexGroup(self):
            return self.getTypedRuleContext(regexParser.RegexGroupContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupPattern" ):
                listener.enterGroupPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupPattern" ):
                listener.exitGroupPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupPattern" ):
                return visitor.visitGroupPattern(self)
            else:
                return visitor.visitChildren(self)


    class CharacterClassContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CHARACTER_CLASS(self):
            return self.getToken(regexParser.CHARACTER_CLASS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharacterClass" ):
                listener.enterCharacterClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharacterClass" ):
                listener.exitCharacterClass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharacterClass" ):
                return visitor.visitCharacterClass(self)
            else:
                return visitor.visitChildren(self)


    class CaretAnchorContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CARET(self):
            return self.getToken(regexParser.CARET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaretAnchor" ):
                listener.enterCaretAnchor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaretAnchor" ):
                listener.exitCaretAnchor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaretAnchor" ):
                return visitor.visitCaretAnchor(self)
            else:
                return visitor.visitChildren(self)


    class DollarAnchorContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOLLAR(self):
            return self.getToken(regexParser.DOLLAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDollarAnchor" ):
                listener.enterDollarAnchor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDollarAnchor" ):
                listener.exitDollarAnchor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDollarAnchor" ):
                return visitor.visitDollarAnchor(self)
            else:
                return visitor.visitChildren(self)


    class EscapedReservedAtomicPatternContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ESCAPED_RESERVED_CHAR(self):
            return self.getToken(regexParser.ESCAPED_RESERVED_CHAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscapedReservedAtomicPattern" ):
                listener.enterEscapedReservedAtomicPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscapedReservedAtomicPattern" ):
                listener.exitEscapedReservedAtomicPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscapedReservedAtomicPattern" ):
                return visitor.visitEscapedReservedAtomicPattern(self)
            else:
                return visitor.visitChildren(self)


    class AtomicPatternContext(SubexprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.SubexprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atomicChar(self):
            return self.getTypedRuleContext(regexParser.AtomicCharContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomicPattern" ):
                listener.enterAtomicPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomicPattern" ):
                listener.exitAtomicPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomicPattern" ):
                return visitor.visitAtomicPattern(self)
            else:
                return visitor.visitChildren(self)



    def subexpr(self):

        localctx = regexParser.SubexprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_subexpr)
        try:
            self.state = 57
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [regexParser.OPEN_PAR]:
                localctx = regexParser.GroupPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.regexGroup()
                pass
            elif token in [regexParser.CLOSE_BRACKET, regexParser.DASH, regexParser.GREATER_THAN, regexParser.LOWER_THAN, regexParser.COLON, regexParser.CHAR]:
                localctx = regexParser.AtomicPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 49
                self.atomicChar()
                pass
            elif token in [regexParser.ESCAPED_RESERVED_CHAR]:
                localctx = regexParser.EscapedReservedAtomicPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 50
                self.match(regexParser.ESCAPED_RESERVED_CHAR)
                pass
            elif token in [regexParser.CHARACTER_CLASS]:
                localctx = regexParser.CharacterClassContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 51
                self.match(regexParser.CHARACTER_CLASS)
                pass
            elif token in [regexParser.OPEN_BRACKET]:
                localctx = regexParser.ComplexClassContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 52
                self.complexCharacterClass()
                pass
            elif token in [regexParser.BACKREFERENCE]:
                localctx = regexParser.BackreferenceContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 53
                self.match(regexParser.BACKREFERENCE)
                pass
            elif token in [regexParser.DOLLAR]:
                localctx = regexParser.DollarAnchorContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 54
                self.match(regexParser.DOLLAR)
                pass
            elif token in [regexParser.CARET]:
                localctx = regexParser.CaretAnchorContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 55
                self.match(regexParser.CARET)
                pass
            elif token in [regexParser.DOT]:
                localctx = regexParser.DotPatternContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 56
                self.match(regexParser.DOT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegexGroupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._CHAR = None # Token
            self.name = list() # of Tokens
            self.nonCapture = None # Token
            self.atomic = None # Token

        def OPEN_PAR(self):
            return self.getToken(regexParser.OPEN_PAR, 0)

        def regex(self):
            return self.getTypedRuleContext(regexParser.RegexContext,0)


        def CLOSE_PAR(self):
            return self.getToken(regexParser.CLOSE_PAR, 0)

        def QUESTION_MARK(self):
            return self.getToken(regexParser.QUESTION_MARK, 0)

        def COLON(self):
            return self.getToken(regexParser.COLON, 0)

        def GREATER_THAN(self):
            return self.getToken(regexParser.GREATER_THAN, 0)

        def LOWER_THAN(self):
            return self.getToken(regexParser.LOWER_THAN, 0)

        def CHAR(self, i:int=None):
            if i is None:
                return self.getTokens(regexParser.CHAR)
            else:
                return self.getToken(regexParser.CHAR, i)

        def getRuleIndex(self):
            return regexParser.RULE_regexGroup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegexGroup" ):
                listener.enterRegexGroup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegexGroup" ):
                listener.exitRegexGroup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegexGroup" ):
                return visitor.visitRegexGroup(self)
            else:
                return visitor.visitChildren(self)




    def regexGroup(self):

        localctx = regexParser.RegexGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_regexGroup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self.match(regexParser.OPEN_PAR)
            self.state = 72
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==regexParser.QUESTION_MARK:
                self.state = 60
                self.match(regexParser.QUESTION_MARK)
                self.state = 70
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [regexParser.LOWER_THAN]:
                    self.state = 61
                    self.match(regexParser.LOWER_THAN)
                    self.state = 63 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 62
                        localctx._CHAR = self.match(regexParser.CHAR)
                        localctx.name.append(localctx._CHAR)
                        self.state = 65 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==regexParser.CHAR):
                            break

                    self.state = 67
                    self.match(regexParser.GREATER_THAN)
                    pass
                elif token in [regexParser.COLON]:
                    self.state = 68
                    localctx.nonCapture = self.match(regexParser.COLON)
                    pass
                elif token in [regexParser.GREATER_THAN]:
                    self.state = 69
                    localctx.atomic = self.match(regexParser.GREATER_THAN)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 74
            self.regex()
            self.state = 75
            self.match(regexParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComplexCharacterClassContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.negated = None # Token

        def OPEN_BRACKET(self):
            return self.getToken(regexParser.OPEN_BRACKET, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(regexParser.CLOSE_BRACKET, 0)

        def complexCCPiece(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(regexParser.ComplexCCPieceContext)
            else:
                return self.getTypedRuleContext(regexParser.ComplexCCPieceContext,i)


        def CARET(self):
            return self.getToken(regexParser.CARET, 0)

        def getRuleIndex(self):
            return regexParser.RULE_complexCharacterClass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexCharacterClass" ):
                listener.enterComplexCharacterClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexCharacterClass" ):
                listener.exitComplexCharacterClass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexCharacterClass" ):
                return visitor.visitComplexCharacterClass(self)
            else:
                return visitor.visitChildren(self)




    def complexCharacterClass(self):

        localctx = regexParser.ComplexCharacterClassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_complexCharacterClass)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(regexParser.OPEN_BRACKET)
            self.state = 79
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 78
                localctx.negated = self.match(regexParser.CARET)


            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << regexParser.ESCAPED_RESERVED_CHAR) | (1 << regexParser.CHARACTER_CLASS) | (1 << regexParser.OPEN_PAR) | (1 << regexParser.CLOSE_PAR) | (1 << regexParser.ASTERISK) | (1 << regexParser.PLUS) | (1 << regexParser.DOT) | (1 << regexParser.QUESTION_MARK) | (1 << regexParser.OPEN_BRACKET) | (1 << regexParser.DASH) | (1 << regexParser.GREATER_THAN) | (1 << regexParser.LOWER_THAN) | (1 << regexParser.COLON) | (1 << regexParser.CARET) | (1 << regexParser.DOLLAR) | (1 << regexParser.CHAR))) != 0):
                self.state = 81
                self.complexCCPiece()
                self.state = 86
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 87
            self.match(regexParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComplexCCPieceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return regexParser.RULE_complexCCPiece

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class CcPiece_ResponeContext(ComplexCCPieceContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.ComplexCCPieceContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def allowedCharInCharacterClass(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(regexParser.AllowedCharInCharacterClassContext)
            else:
                return self.getTypedRuleContext(regexParser.AllowedCharInCharacterClassContext,i)

        def DASH(self):
            return self.getToken(regexParser.DASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCcPiece_Respone" ):
                listener.enterCcPiece_Respone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCcPiece_Respone" ):
                listener.exitCcPiece_Respone(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCcPiece_Respone" ):
                return visitor.visitCcPiece_Respone(self)
            else:
                return visitor.visitChildren(self)


    class CcPiece_EscapeContext(ComplexCCPieceContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.ComplexCCPieceContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CHARACTER_CLASS(self):
            return self.getToken(regexParser.CHARACTER_CLASS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCcPiece_Escape" ):
                listener.enterCcPiece_Escape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCcPiece_Escape" ):
                listener.exitCcPiece_Escape(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCcPiece_Escape" ):
                return visitor.visitCcPiece_Escape(self)
            else:
                return visitor.visitChildren(self)



    def complexCCPiece(self):

        localctx = regexParser.ComplexCCPieceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_complexCCPiece)
        try:
            self.state = 95
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [regexParser.ESCAPED_RESERVED_CHAR, regexParser.OPEN_PAR, regexParser.CLOSE_PAR, regexParser.ASTERISK, regexParser.PLUS, regexParser.DOT, regexParser.QUESTION_MARK, regexParser.OPEN_BRACKET, regexParser.DASH, regexParser.GREATER_THAN, regexParser.LOWER_THAN, regexParser.COLON, regexParser.CARET, regexParser.DOLLAR, regexParser.CHAR]:
                localctx = regexParser.CcPiece_ResponeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 89
                self.allowedCharInCharacterClass()
                self.state = 92
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                if la_ == 1:
                    self.state = 90
                    self.match(regexParser.DASH)
                    self.state = 91
                    self.allowedCharInCharacterClass()


                pass
            elif token in [regexParser.CHARACTER_CLASS]:
                localctx = regexParser.CcPiece_EscapeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 94
                self.match(regexParser.CHARACTER_CLASS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AllowedCharInCharacterClassContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHAR(self):
            return self.getToken(regexParser.CHAR, 0)

        def DASH(self):
            return self.getToken(regexParser.DASH, 0)

        def OPEN_BRACKET(self):
            return self.getToken(regexParser.OPEN_BRACKET, 0)

        def OPEN_PAR(self):
            return self.getToken(regexParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(regexParser.CLOSE_PAR, 0)

        def ASTERISK(self):
            return self.getToken(regexParser.ASTERISK, 0)

        def PLUS(self):
            return self.getToken(regexParser.PLUS, 0)

        def DOT(self):
            return self.getToken(regexParser.DOT, 0)

        def QUESTION_MARK(self):
            return self.getToken(regexParser.QUESTION_MARK, 0)

        def ESCAPED_RESERVED_CHAR(self):
            return self.getToken(regexParser.ESCAPED_RESERVED_CHAR, 0)

        def GREATER_THAN(self):
            return self.getToken(regexParser.GREATER_THAN, 0)

        def LOWER_THAN(self):
            return self.getToken(regexParser.LOWER_THAN, 0)

        def COLON(self):
            return self.getToken(regexParser.COLON, 0)

        def CARET(self):
            return self.getToken(regexParser.CARET, 0)

        def DOLLAR(self):
            return self.getToken(regexParser.DOLLAR, 0)

        def getRuleIndex(self):
            return regexParser.RULE_allowedCharInCharacterClass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllowedCharInCharacterClass" ):
                listener.enterAllowedCharInCharacterClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllowedCharInCharacterClass" ):
                listener.exitAllowedCharInCharacterClass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAllowedCharInCharacterClass" ):
                return visitor.visitAllowedCharInCharacterClass(self)
            else:
                return visitor.visitChildren(self)




    def allowedCharInCharacterClass(self):

        localctx = regexParser.AllowedCharInCharacterClassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_allowedCharInCharacterClass)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << regexParser.ESCAPED_RESERVED_CHAR) | (1 << regexParser.OPEN_PAR) | (1 << regexParser.CLOSE_PAR) | (1 << regexParser.ASTERISK) | (1 << regexParser.PLUS) | (1 << regexParser.DOT) | (1 << regexParser.QUESTION_MARK) | (1 << regexParser.OPEN_BRACKET) | (1 << regexParser.DASH) | (1 << regexParser.GREATER_THAN) | (1 << regexParser.LOWER_THAN) | (1 << regexParser.COLON) | (1 << regexParser.CARET) | (1 << regexParser.DOLLAR) | (1 << regexParser.CHAR))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomicCharContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHAR(self):
            return self.getToken(regexParser.CHAR, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(regexParser.CLOSE_BRACKET, 0)

        def DASH(self):
            return self.getToken(regexParser.DASH, 0)

        def GREATER_THAN(self):
            return self.getToken(regexParser.GREATER_THAN, 0)

        def LOWER_THAN(self):
            return self.getToken(regexParser.LOWER_THAN, 0)

        def COLON(self):
            return self.getToken(regexParser.COLON, 0)

        def getRuleIndex(self):
            return regexParser.RULE_atomicChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomicChar" ):
                listener.enterAtomicChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomicChar" ):
                listener.exitAtomicChar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomicChar" ):
                return visitor.visitAtomicChar(self)
            else:
                return visitor.visitChildren(self)




    def atomicChar(self):

        localctx = regexParser.AtomicCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_atomicChar)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << regexParser.CLOSE_BRACKET) | (1 << regexParser.DASH) | (1 << regexParser.GREATER_THAN) | (1 << regexParser.LOWER_THAN) | (1 << regexParser.COLON) | (1 << regexParser.CHAR))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return regexParser.RULE_quantifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LazyAsteriskQuantifierContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ASTERISK(self):
            return self.getToken(regexParser.ASTERISK, 0)
        def QUESTION_MARK(self):
            return self.getToken(regexParser.QUESTION_MARK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLazyAsteriskQuantifier" ):
                listener.enterLazyAsteriskQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLazyAsteriskQuantifier" ):
                listener.exitLazyAsteriskQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLazyAsteriskQuantifier" ):
                return visitor.visitLazyAsteriskQuantifier()
            else:
                return visitor.visitChildren(self)


    class LazyPlusQuantifierContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PLUS(self):
            return self.getToken(regexParser.PLUS, 0)
        def QUESTION_MARK(self):
            return self.getToken(regexParser.QUESTION_MARK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLazyPlusQuantifier" ):
                listener.enterLazyPlusQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLazyPlusQuantifier" ):
                listener.exitLazyPlusQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLazyPlusQuantifier" ):
                return visitor.visitLazyPlusQuantifier()
            else:
                return visitor.visitChildren(self)


    class QuestionQuantifierContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def QUESTION_MARK(self):
            return self.getToken(regexParser.QUESTION_MARK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuestionQuantifier" ):
                listener.enterQuestionQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuestionQuantifier" ):
                listener.exitQuestionQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuestionQuantifier" ):
                return visitor.visitQuestionQuantifier()
            else:
                return visitor.visitChildren(self)


    class LazyQuestionQuantifierContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def QUESTION_MARK(self, i:int=None):
            if i is None:
                return self.getTokens(regexParser.QUESTION_MARK)
            else:
                return self.getToken(regexParser.QUESTION_MARK, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLazyQuestionQuantifier" ):
                listener.enterLazyQuestionQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLazyQuestionQuantifier" ):
                listener.exitLazyQuestionQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLazyQuestionQuantifier" ):
                return visitor.visitLazyQuestionQuantifier()
            else:
                return visitor.visitChildren(self)


    class PlusQuantifierContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PLUS(self):
            return self.getToken(regexParser.PLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlusQuantifier" ):
                listener.enterPlusQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlusQuantifier" ):
                listener.exitPlusQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlusQuantifier" ):
                #print("self inside accept: "+str(self))
                #return visitor.visitPlusQuantifier(self)
                return visitor.visitPlusQuantifier()
            else:
                return visitor.visitChildren(self)


    class AsteriskQuantifierContext(QuantifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a regexParser.QuantifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ASTERISK(self):
            return self.getToken(regexParser.ASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAsteriskQuantifier" ):
                listener.enterAsteriskQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAsteriskQuantifier" ):
                listener.exitAsteriskQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAsteriskQuantifier" ):
                return visitor.visitAsteriskQuantifier()
            else:
                return visitor.visitChildren(self)



    def quantifier(self):

        localctx = regexParser.QuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_quantifier)
        try:
            self.state = 110
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                localctx = regexParser.AsteriskQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.match(regexParser.ASTERISK)
                pass

            elif la_ == 2:
                localctx = regexParser.PlusQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.match(regexParser.PLUS)
                pass

            elif la_ == 3:
                localctx = regexParser.QuestionQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.match(regexParser.QUESTION_MARK)
                pass

            elif la_ == 4:
                localctx = regexParser.LazyAsteriskQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 104
                self.match(regexParser.ASTERISK)
                self.state = 105
                self.match(regexParser.QUESTION_MARK)
                pass

            elif la_ == 5:
                localctx = regexParser.LazyPlusQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 106
                self.match(regexParser.PLUS)
                self.state = 107
                self.match(regexParser.QUESTION_MARK)
                pass

            elif la_ == 6:
                localctx = regexParser.LazyQuestionQuantifierContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 108
                self.match(regexParser.QUESTION_MARK)
                self.state = 109
                self.match(regexParser.QUESTION_MARK)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





